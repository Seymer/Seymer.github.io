<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>ANSI COMMON LISP</title>
<!-- 2018-02-01 Thu 17:47 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Siqing Mu" />
<link rel="shortcut icon" href="https://www.khow.me/blog-cn/images/favicon.ico" />
<link rel="stylesheet" type="text/css" href="./css/site.css" />
</head>
<body>
<div id="content">
<h1 class="title">ANSI COMMON LISP</h1>
<ul class="org-ul">
<li>quote 作为一种引用，也就是什么也不做，它的另一种表达形式是’
</li>

<li>空列表的两种表达形式，（） nil
</li>

<li>cons 用来构造列表，可以将多个列表合并为一个列表
</li>

<li>car 和 cdr 是一对亲兄弟，car 用来取列表第一个元素，cdr 用来取除第一个的剩余元素
</li>

<li>third 可以取第三个元素
</li>

<li>t 代表逻辑真，与 nil 一样，都是对自身求值
</li>

<li>listp 用来判断实参是否为列表，真则为 T ，假则为 NIL 
</li>
</ul>

<blockquote>
<p>

</p>

<p>
函数的返回值将会被解释成逻辑 真 或逻辑 假 时，则称此函数为谓词（predicate)
在 Common Lisp 里，谓词的名字通常以 p 结尾。
</p>
</blockquote>

<ul class="org-ul">
<li>null 和 not 用来判断实参是否为空
</li>

<li>if 和 qunto 都是特殊操作符，不能用函数实现，因为实参被调用时永远会被求值，

<p>
而 if 只有最后两个实参其中一个会被求值。
</p>
</li>

<li>if 的最后一个实参是选择性的。如果忽略它的话，缺省值是 nil
</li>

<li>逻辑操作符 and 和 or ，两者都接受任意数量实参。如果所有实参同为真，and 则对能求值部分求值，否则为 nil, or 只要碰到一个为 真 的实参，则停止之后实参求值。
</li>

<li>and 和 or 操作符其实是宏，宏和特殊操作符一样，可以绕过一般求值规则。
</li>

<li>用 defun 来定义函数
</li>

<li>符号是变量的名字，符号本身就是以对象的方式存在。这也是为什么符号，必须像列表一样被引用。
列表必须被引用，不然会被视为代码。符号必须要被引用，不然会被当作变量。
</li>

<li>member 测试某个东西是否为列表成员
</li>

<li>谓词 eql 用来判断它的两个实参是否相等
</li>

<li>输出函数 format 接受两个或两个以上的实参，第一个决定打印到哪儿，第二个是字符串模版，剩余是要插入到字符串模板的参数。
</li>

<li>format 第一个实参 t 表示输出到缺省位置，通常是顶层。字符串模板里 ~A 表示被填入的位置，~% 表示一个换行。
</li>

<li>输入函数 read 当没有实参时，会读取缺省位置，通常是顶层。read 是一个完整的 Lisp 解析器。
</li>

<li>let 用来定义局部变量，由两部分组成，第一部分是一组创建新变量的指令，第二部分是一个表达式。
</li>

<li>numberp 用来检测是否为数字
</li>

<li>defparameter 用来创建全局变量，由符号和值两部分组成。为了避免与局部变量发生冲突，在命名时以星号作开始结束。
</li>

<li>defconstant 用来定义一个全局常量。
</li>

<li>boundp 函数用来判断某些符号是否是一个全局变量或常量。
</li>

<li>setf 操作符用来给全局或局部变量赋值。
</li>

<li>如果 setf 的第一个实参是符号（symbol），且符号不是某个局部变量的名字，则 setf 把这个符号设为全局变量
</li>

<li>你不仅可以给变量赋值。传入 setf 的第一个实参，还可以是表达式或变量名。
</li>

<li>你可以给 setf 传入（偶数）个实参，等同于分别对其传参。
</li>

<li>函数 remove 接受一个对象和一个列表，返回不含这个对象的新列表。这里注意：remove 不是从列表内移除对象，因为原来的列表并没有改变。
</li>

<li>如果要真正移除列表内元素，可以和 setf 搭配，remove 后将数据重写会原列表。例如：(setf lst (remove 'a lst))
</li>

<li>do 宏是 Common Lisp 里最基本的迭代操作符。和 let 类似， do 可以创建变量，而第一个实参是一组变量的规格说明列表。
</li>

<li>progn 接受任意数量的表达式，依序求值，并返回最后一个表达式的值。
</li>

<li>dolist 用来遍历列表元素
</li>

<li>function 是一个特殊操作符，将函数名传给它可以返回相关联的对象，而且无需引用。
</li>

<li>如同 quote 可以用 ’ 代替，function 也可以用 #‘ 代替，#‘ 称为升引号。
</li>

<li>apply 接受一个函数和实参列表，并返回把传入函数应用在实参列表的结果。可以接受任意多实参，只要左后一个实参时列表即可。
</li>

<li>funcall 和 apply 类似，但无需将实参包装成列表。
</li>

<li>lambda 不是操作符而是个符号
</li>

<li>要直接引用一个函数，我们使用所谓的lambda 表达式
</li>

<li>lambda 表达式也可以是函数调用的第一个元素，例如： ((lambda (x) (+ x 100)) 1)
</li>

<li>通过在 lambda 表达式前面贴上 #' ，我们得到对应的函数。(funcall #'(lambda (x) (+ x 100)) 1）
</li>

<li>lambda 还允许我们使用匿名函数
</li>

<li>函数 typep 接受一个对象和一个类型，然后判定对象是否为该类型
</li>

<li>common lisp 的内置类型，对象总是不止属于某种类型。例如：数字21有 fixnum 、 integer 、 rational 、 real 、 number 、 atom 和 t 类型，t 为所有类型的基类。
</li>

<li></li>
</ul>
</div>
</body>
</html>
